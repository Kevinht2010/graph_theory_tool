[{"D:\\Graph Theory Tool\\front\\src\\index.js":"1","D:\\Graph Theory Tool\\front\\src\\App.js":"2","D:\\Graph Theory Tool\\front\\src\\reportWebVitals.js":"3","D:\\Graph Theory Tool\\front\\src\\logic\\graph\\Graph.js":"4","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Planarity.js":"5","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Hamiltonian.js":"6","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\SpanTrees.js":"7","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Cycles.js":"8","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Components.js":"9","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\BFS.js":"10","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\GraphVisual.js":"11","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Edge.js":"12","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Node.js":"13","D:\\Graph Theory Tool\\front\\src\\display\\data\\Data.js":"14","D:\\Graph Theory Tool\\front\\src\\display\\input\\Inputs.js":"15","D:\\Graph Theory Tool\\front\\src\\display\\input\\InputGraph.js":"16","D:\\Graph Theory Tool\\front\\src\\display\\authentication\\Authentication.js":"17","D:\\Graph Theory Tool\\front\\src\\routing\\Routes.js":"18","D:\\Graph Theory Tool\\front\\src\\display\\authentication\\TokenPage.js":"19"},{"size":500,"mtime":1608943103064,"results":"20","hashOfConfig":"21"},{"size":831,"mtime":1610267997618,"results":"22","hashOfConfig":"21"},{"size":362,"mtime":1608943103064,"results":"23","hashOfConfig":"21"},{"size":2400,"mtime":1609225751772,"results":"24","hashOfConfig":"21"},{"size":107,"mtime":1608957101461,"results":"25","hashOfConfig":"21"},{"size":295,"mtime":1608961678554,"results":"26","hashOfConfig":"21"},{"size":106,"mtime":1608957102494,"results":"27","hashOfConfig":"21"},{"size":466,"mtime":1609028646681,"results":"28","hashOfConfig":"21"},{"size":1282,"mtime":1609225152031,"results":"29","hashOfConfig":"21"},{"size":3215,"mtime":1608979201557,"results":"30","hashOfConfig":"21"},{"size":3804,"mtime":1610174785645,"results":"31","hashOfConfig":"21"},{"size":1996,"mtime":1609985865712,"results":"32","hashOfConfig":"21"},{"size":739,"mtime":1609330868472,"results":"33","hashOfConfig":"21"},{"size":7933,"mtime":1610083362065,"results":"34","hashOfConfig":"21"},{"size":12687,"mtime":1610174766742,"results":"35","hashOfConfig":"21"},{"size":1850,"mtime":1610094467255,"results":"36","hashOfConfig":"21"},{"size":1164,"mtime":1610267794077,"results":"37","hashOfConfig":"21"},{"size":561,"mtime":1610267981450,"results":"38","hashOfConfig":"21"},{"size":840,"mtime":1610267787253,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"cgvn3b",{"filePath":"43","messages":"44","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"42"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"42"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"42"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"42"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"42"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"42"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"79","usedDeprecatedRules":"42"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"D:\\Graph Theory Tool\\front\\src\\index.js",[],["86","87"],"D:\\Graph Theory Tool\\front\\src\\App.js",["88","89","90","91","92","93"],"D:\\Graph Theory Tool\\front\\src\\reportWebVitals.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\graph\\Graph.js",["94","95","96","97","98"],"import Cycles from '../algorithms/Cycles'\r\nimport Hamiltonian from '../algorithms/Hamiltonian'\r\nimport Planarity from '../algorithms/Planarity'\r\nimport SpanTrees from '../algorithms/SpanTrees'\r\nimport Components from '../algorithms/Components'\r\n\r\n\r\nclass Graph {\r\n    constructor(adjMatrix) {\r\n        this.list = this.makeAdjacenyList(adjMatrix);\r\n        this.matrix = adjMatrix;\r\n    }\r\n\r\n    makeAdjacenyList = (m) => {\r\n        let list = [];\r\n        for(let v = 0; v < m.length; ++v) {\r\n            let current = [];\r\n            for(let i = 0; i < m.length; ++i) {\r\n                if(m[v][i] == 1) {\r\n                    current.push(i);\r\n                }\r\n            }\r\n\r\n            list.push(current);\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    getCompleteSubgraph(vertices) {\r\n        \r\n    }\r\n\r\n    getSubgraph(vertices, adjacencyList) {\r\n\r\n    }\r\n\r\n    getRequirement = (requirement) => {\r\n        if(requirement == \"components\") {\r\n            this.getComponents();\r\n        }\r\n    }\r\n\r\n    // returns the number of components in G;\r\n    getComponents = () => {\r\n        const components = Components(this);\r\n        this.compenents = components.getComponents();\r\n    }\r\n\r\n    // returns all hamiltonian cycles in G;\r\n    getHamiltonianCycles = () => {\r\n        const hamiltonian = Hamiltonian(this);\r\n        this.hamiltonianCycleCount = hamiltonian.getHamiltonianCycleCount();\r\n        this.hamiltonianCycles = hamiltonian.getHamiltonianCycles();\r\n    }\r\n    \r\n\r\n}\r\n\r\nexport default Graph;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* // returns an array of graphs (which are subgraphs of G which happen to be spanning trees/forests)\r\n    spanTrees = () => {\r\n        const trees = SpanTrees.getTrees(this);\r\n        return trees;\r\n    }\r\n\r\n    // returns the number of spanning trees\r\n    numberOfSpanTrees = () => {\r\n        const treeCount = SpanTrees.getTreeCount(this);\r\n        return treeCount;\r\n    }\r\n\r\n    // returns a boolean as to whether or not this graph is planar\r\n    planarity = () => {\r\n        let b = Planarity.getPlanarity(this);\r\n        return b;\r\n    }\r\n\r\n    // returns a K_(3,3) or K_5 subdivision\r\n    nonPlanar = () => {\r\n        let b = Planarity.getSubdivision(this);\r\n        return b;\r\n    }\r\n\r\n    // returns smallest + largest cycle in G (array of Graphs);\r\n    cycles = () => {\r\n        const cycleArray = Cycles.getCycles(this);\r\n        return cycleArray;\r\n    }\r\n*/","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Planarity.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Hamiltonian.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\SpanTrees.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Cycles.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Components.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\BFS.js",["99","100","101"],"// returns an array of all the paths branching from one vertex\r\nfunction BFSRepeat(G, vertex) {\r\n    let paths = [[vertex]];\r\n    let finishedPaths = [];\r\n    let list = G.list;\r\n\r\n    while(paths.length > 0) {\r\n        let newPaths = [];\r\n        for(let i = 0; i < paths.length; ++i) {\r\n            let path = paths[i];\r\n            let prevLength = newPaths.length;\r\n            let idx = path[path.length - 1];\r\n            for(let v of list[idx]) {\r\n                if(!path.includes(v)) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    newPaths.push(newPath);\r\n                }\r\n            }\r\n\r\n            if(prevLength == newPaths.length) {\r\n                finishedPaths.push(path);\r\n                paths.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n        paths = newPaths;\r\n    }\r\n    return finishedPaths;\r\n}\r\n\r\nfunction BFSCycle(G, vertex) {\r\n    let paths = [[vertex]];\r\n    let finishedPaths = [];\r\n    let list = G.list;\r\n\r\n    while(paths.length > 0) {\r\n        let newPaths = [];\r\n        for(let i = 0; i < paths.length; ++i) {\r\n            let path = paths[i];\r\n            let prevLength = newPaths.length;\r\n            let idx = path[path.length - 1];\r\n            for(let v of list[idx]) {\r\n                if(!path.includes(v)) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    newPaths.push(newPath);\r\n                }\r\n\r\n                if(v === vertex && path.length > 2) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    finishedPaths.push(newPath);\r\n                }\r\n            }\r\n\r\n            if(prevLength == newPaths.length) {\r\n                paths.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n        paths = newPaths;\r\n    }\r\n    \r\n    for(let path of finishedPaths) {\r\n        if(path[1] > path[path.length - 2]) {\r\n            path.reverse();\r\n        }\r\n    }\r\n\r\n    let finishedCycles = Array.from(new Set(finishedPaths.map(JSON.stringify)), JSON.parse);\r\n\r\n    return finishedCycles;\r\n}\r\n\r\n// input: G is the graph, vertex is the starting vertex, and removedVertices\r\n// is an array consisting of the vertices currently in your search already\r\n// (array of 1's and 0's, 1 meaning the vertex is included, 0 meaning not included)\r\n\r\n// returns two arrays: One with all the vertices you can reach in the bfs, \r\n// and one with all the vertices you cannot reach using bfs\r\n\r\nfunction BFSNoRepeat(G, vertex, vertices) {\r\n    let list = G.list;\r\n    let currentVertices = [vertex];\r\n    let vertexMap = vertices;\r\n\r\n    vertexMap[vertex] = 1;\r\n\r\n    while(currentVertices.length > 0) {\r\n        let newVertices = [];\r\n        for(let v of currentVertices) {\r\n            for(let i = 0; i < list[v].length; ++i) {\r\n                if(vertexMap[list[v][i]] != 1) {\r\n                    ++vertexMap[list[v][i]];\r\n                    newVertices.push(list[v][i]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        currentVertices = newVertices.slice(0);\r\n    }\r\n    \r\n    return vertexMap;\r\n}\r\n\r\nexport {BFSRepeat, BFSNoRepeat, BFSCycle};\r\n\r\n","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\GraphVisual.js",["102"],"import React, {useState, useEffect, useRef} from 'react';\r\nimport Node from './Node';\r\nimport Edge from './Edge';\r\n\r\nexport default function GraphVisual(props) {\r\n    const [mouseIn, setMouseIn] = useState(false);\r\n    const [dragId, setDragId] = useState();\r\n    const [isDraggingNode, setIsDraggingNode] = useState(false);\r\n    const [isDraggingEdge, setIsDraggingEdge] = useState(false);\r\n\r\n    const [originX, setOriginX] = useState(0);\r\n    const [originY, setOriginY] = useState(0);\r\n    const [prevPosition, setPrevPosition] = useState([]);\r\n\r\n    const dragStart = (e, id, node) => {\r\n        if(mouseIn === true) {\r\n            if(props.deletingVertex) {\r\n                props.deleteVertex(id);\r\n                return;\r\n            }\r\n            setDragId(id);\r\n            setOriginX(e.clientX);\r\n            setOriginY(e.clientY);\r\n\r\n            if(node) {\r\n                setIsDraggingNode(true);\r\n                setPrevPosition([props.vertices[id].posX, props.vertices[id].posY]);\r\n            } else {\r\n                setIsDraggingEdge(true);\r\n                if(props.bendPositions.get(id).bent === true) {\r\n                    setPrevPosition([props.bendPositions.get(id).posX, props.bendPositions.get(id).posY]);\r\n                } else {  \r\n                    let node1 = props.vertices[props.edges.get(id).node1];\r\n                    let node2 = props.vertices[props.edges.get(id).node2];\r\n                    setPrevPosition([(node1.posX + node2.posX) / 2, (node1.posY + node2.posY) / 2]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const dragging = (e) => {\r\n        if(isDraggingNode && mouseIn) {\r\n            let newX = e.clientX - originX;\r\n            let newY =  e.clientY - originY;\r\n            updateData({\r\n                \"id\": dragId, \r\n                \"posX\": prevPosition[0] + newX, \r\n                \"posY\": prevPosition[1] + newY\r\n            });\r\n        } else if(isDraggingEdge && mouseIn) {\r\n            let newX = e.clientX - originX;\r\n            let newY =  e.clientY - originY;\r\n            updateBendPositions({\r\n                \"id\": dragId, \r\n                \"posX\": prevPosition[0] + newX, \r\n                \"posY\": prevPosition[1] + newY,\r\n                \"bent\": true\r\n            });\r\n        }\r\n    }\r\n\r\n    const dragEnd = () => {\r\n        setIsDraggingNode(false);\r\n        setIsDraggingEdge(false);\r\n    }\r\n\r\n    const updateData = (a) => {\r\n        let newVertices = props.vertices.slice(0);\r\n        newVertices[a.id] = a;\r\n        props.setVertices(newVertices);\r\n    }\r\n\r\n    const updateBendPositions = (a) => {\r\n        let newBendPositions = new Map(props.bendPositions.set(a.id, a));\r\n        props.setBendPositions(newBendPositions);\r\n    }\r\n\r\n    const updateVertices = (a) => {\r\n        return props.vertices.map(node => {\r\n            return (<Node dragStart={dragStart} dragEnd={dragEnd} id={node.id} position={[node.posX, node.posY]}/>);\r\n        })\r\n    }\r\n\r\n    const updateEdges = (a) => {\r\n        let e = [];\r\n        props.edges.forEach((edge) => {\r\n            e.push(<Edge dragStart={dragStart} dragEnd={dragEnd} id={edge.id} node1={props.vertices[edge.node1]} \r\n                    node2={props.vertices[edge.node2]} bendPos={props.bendPositions.get(edge.id)}/>)\r\n        })\r\n        return e;\r\n    }\r\n\r\n    useEffect(() => {}, [props.vertices, props.bendPositions, props.bendPositions, props.edges, props.vertices])\r\n\r\n    return (\r\n        <svg style={{height:\"600vh\", width:\"600vw\", backgroundColor: '#dbedff'}} \r\n            onMouseOver={() => {setMouseIn(true)}} onMouseLeave={(e) => {dragging(e); setMouseIn(false); dragEnd()}}\r\n            onMouseMove={(e) => {dragging(e)}} onMouseUp={() => dragEnd()}>\r\n            {updateEdges()}\r\n            {updateVertices()}\r\n        </svg>\r\n    )\r\n}\r\n\r\n","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Edge.js",["103"],"import React, {useState, useEffect} from 'react'\r\n\r\nfunction Edge(props) {\r\n    const [node1, setNode1] = useState(props.node1);\r\n    const [node2, setNode2] = useState(props.node2);\r\n    const [bendPos, setBendPos] = useState(props.bendPos);\r\n\r\n    let c;\r\n    let d;\r\n    if(props.bendPos.bent === false) {\r\n        c = [(node1.posX + node2.posX)/2, (node1.posY + node2.posY)/2];\r\n        d = \"M \" + node1.posX + \" \" + node1.posY + \" Q \" + c[0] + \" \" + c[1] + \" \" + node2.posX + \" \" + node2.posY;\r\n    } else {\r\n        c = [props.bendPos.posX, props.bendPos.posY];\r\n        d = calcCirclePath([[node2.posX, node2.posY], c, [node1.posX, node1.posY]]);\r\n    }\r\n\r\n    useEffect(() => {\r\n        setNode1(props.node1); setNode2(props.node2);\r\n        setBendPos(props.bendPos);\r\n    }, [props.node1, props.node2, props.bendPos])\r\n\r\n    return (\r\n        <svg>\r\n            <svg>\r\n                <circle onMouseDown={(e) => {props.dragStart(e, props.id, false);}} onMouseUp={(e) => props.dragEnd(e)} cx={c[0]} cy={c[1]} r={6}/>\r\n            </svg>\r\n            <svg>\r\n                <path pointer-events=\"none\" d={d} stroke=\"black\" fill=\"transparent\" stroke-width=\"3\" shape-rendering=\"geometricPrecision\"/>\r\n            </svg>\r\n        </svg>\r\n    )\r\n}\r\n\r\nfunction calcCirclePath(points){\r\n    var a = points[0]\r\n    var b = points[2]\r\n    var c = points[1]\r\n  \r\n    var A = dist(b, c)\r\n    var B = dist(c, a)\r\n    var C = dist(a, b)\r\n  \r\n    var angle = Math.acos((A*A + B*B - C*C)/(2*A*B))\r\n  \r\n    //calc radius of circle\r\n    var K = .5*A*B*Math.sin(angle)\r\n    var r = A*B*C/4/K\r\n    r = Math.round(r*1000)/1000\r\n  \r\n    //large arc flag\r\n    var laf = +(Math.PI/2 > angle)\r\n  \r\n    //sweep flag\r\n    var saf = +((b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) < 0) \r\n  \r\n    return ['M', a, 'A', r, r, 0, laf, saf, b].join(' ')\r\n  }\r\n  \r\n  function dist(a, b){\r\n    return Math.sqrt(\r\n      Math.pow(a[0] - b[0], 2) +\r\n      Math.pow(a[1] - b[1], 2))\r\n  }\r\n\r\nexport default Edge\r\n","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Node.js",["104"],"import React, {useState, useEffect, useRef} from 'react'\r\n\r\nexport default function Node(props) {\r\n    const [position, setPosition] = useState(props.position);\r\n    \r\n    const labelX = position[0];\r\n    const labelY = position[1];\r\n\r\n    useEffect(() => {\r\n        setPosition(props.position);\r\n    }, [props.position])\r\n\r\n    return (\r\n        <g style={{userSelect:\"none\"}} onMouseDown={e => props.dragStart(e, props.id, true)} onMouseUp={(e) => props.dragEnd(e)}>\r\n            <circle cx={labelX} cy={labelY} r=\"40\" stroke=\"#2ab863\" stroke-width=\"4\" fill=\"#ccffcf\"/>\r\n            <text pointerEvents={\"none\"} textAnchor=\"middle\" transform={`translate(${labelX}, ${labelY + 5})`} fontSize=\"20\">{props.id}</text>\r\n        </g>\r\n    )\r\n}","D:\\Graph Theory Tool\\front\\src\\display\\data\\Data.js",[],"D:\\Graph Theory Tool\\front\\src\\display\\input\\Inputs.js",["105","106","107","108","109","110","111","112"],"import React, {useState, useEffect} from 'react'\r\nimport InputGraph from './InputGraph'\r\nimport { Button, Modal, Checkbox, Input, Form, InputNumber } from 'antd';\r\nimport Authentication from '../authentication/Authentication'\r\n\r\nexport default function Inputs(props) {\r\n    const [showProperties, setShowProperties] = useState(false);\r\n    const [isUpdatingProperties, setIsUpdatingProperties] = useState(false);\r\n    const [showInput, setShowInput] = useState(false);\r\n    const [properties, setProperties] = useState([{\"id\": \"cycles\", \"value\": \"5\"}]);\r\n    const [prevProperties, setPrevProperties] = useState([]);\r\n    const [editEdge, setEditEdge] = useState(false);\r\n    const [addEdge, setAddEdge] = useState(false);\r\n    const [deleteEdge, setDeleteEdge] = useState(false);\r\n    const [addEdgeValidStatus1, setAddEdgeValidStatus1] = useState(\"none\");\r\n    const [addEdgeValidStatus2, setAddEdgeValidStatus2] = useState(\"none\");\r\n    const [graphOptions, setGraphOptions] = useState();\r\n    const [v1, setV1] = useState(\"\");\r\n    const [v2, setV2] = useState(\"\");\r\n\r\n    const [verticesInput, setVerticesInput] = useState(1);\r\n    const [vertices, setVertices] = useState(0);\r\n    const [vertexMessage, setVertexMessage] = useState();\r\n    const [edges, setEdges] = useState();\r\n    const [edgesMessage, setEdgesMessage] = useState();\r\n\r\n\r\n    const options1 = [\"Components\", \"Hamiltonian Cycles\"];\r\n    const options2 = [\"Spanning Trees\", \"Euler Tours\"];\r\n    const options3 = [\"Planarity\", \"Longest/Shortest Cycles\"];\r\n\r\n    const addVertices = () => {\r\n        setVertices(verticesInput);\r\n        let k = Array(verticesInput);\r\n        k.fill([]);\r\n        setEdges(k);\r\n        let m = Array(verticesInput);\r\n        m.fill(\"none\")\r\n        setEdgesMessage(m);\r\n    }\r\n\r\n    const addEdges = () => {\r\n        let inputGraph = new InputGraph(vertices, edges);\r\n        console.log(vertices, edges);\r\n        console.log(inputGraph.valid);\r\n        console.log(inputGraph.errors);\r\n        if(inputGraph.valid === true) {\r\n            props.setVertices(inputGraph.vertices);\r\n            props.setEdges(inputGraph.edges);\r\n            props.setBendPositions(inputGraph.bendPositions)\r\n            clearInput();\r\n        } else {\r\n            setEdgesMessage(inputGraph.errors);\r\n        }\r\n    }\r\n\r\n    const clearInput = () => {\r\n        setVertices(0);\r\n        setShowInput(false); \r\n        setVertexMessage(\"none\");\r\n        setEdges();\r\n        setEdgesMessage();\r\n    }\r\n\r\n    const getGraphInput = () => {\r\n        const footer = (\r\n            <React.Fragment>\r\n                <Button key=\"back\" onClick={() => {clearInput()}}>\r\n                    Cancel\r\n                </Button>\r\n                <Button type=\"primary\" onClick={() => {\r\n                        vertices === 0 ? addVertices() : addEdges();\r\n                    }\r\n                }>\r\n                    {vertices === 0 ? \"Continue\" : \"Input Graph\"}\r\n                </Button>\r\n            </React.Fragment>\r\n        )\r\n\r\n        const hasVertexCount = () => {\r\n            if(vertices === 0) {\r\n                return (\r\n                    <Form.Item\r\n                        label=\"Number of Vertices (Max 20)\"\r\n                        name=\"v1\"\r\n                        validateStatus={addEdgeValidStatus1}\r\n                        help={vertexMessage === \"error\" ? \"Invalid Input\" : null}\r\n                    >\r\n                        <InputNumber onPressEnter={(e) => {setVertices(verticesInput)}} autoComplete=\"off\" onChange={(value) => setVerticesInput(value)} \r\n                                    min={1} max={20} defaultValue={1}/>\r\n                    </Form.Item>\r\n                )\r\n            } else {\r\n                let k = [];\r\n                for(let i = 0; i < vertices; ++i) {\r\n                    k.push(\r\n                        <Form.Item\r\n                            validateStatus={edgesMessage[i]}\r\n                            help={edgesMessage[i] === \"error\" ? \"Invalid Input\" : null}\r\n                            label={JSON.stringify(i)}\r\n                        >\r\n                            <Input defaultValue=\"\" style={{width:\"70px\", margin:\"2px\"}} onPressEnter={(e) => {addEdges()}} autoComplete=\"off\" onChange={(e) => \r\n                                    {let newEdges = [...edges]; newEdges[i] = (e.target.value).split(\" \").join(\"\").split(\",\"); setEdges(newEdges);}} />\r\n                        </Form.Item>\r\n                    )\r\n                }\r\n                return (\r\n                    <React.Fragment>\r\n                        <div style={{marginTop:\"-15px\", marginBottom:\"35px\"}}>Edges (adjacency list, seperating neighbors of each vertex with commas)</div>\r\n                        <div style={{display:\"flex\", width:\"350px\", marginLeft:\"auto\", marginRight:\"auto\", flexWrap:\"wrap\", justifyContent:\"space-around\"}}>\r\n                            {k}\r\n                        </div>\r\n                    </React.Fragment>\r\n                )\r\n            }\r\n        }\r\n\r\n        return (\r\n            <Modal style={{top: \"10%\"}} title=\"Input Graph\" visible={showInput} onCancel={() => {clearInput()}} footer={footer}>\r\n                 <div style={{display:\"flex\", width:\"100%\", justifyContent:\"center\", marginTop:\"10px\", marginBottom:\"-5px\", marginLeft:\"-10px\"}}>\r\n                    <Form\r\n                        onMouseDown={() => {setAddEdgeValidStatus1(\"none\")}}\r\n                        >\r\n                        {hasVertexCount()}\r\n                    </Form>\r\n                 </div>\r\n            </Modal>\r\n        )\r\n    }\r\n\r\n    const getProperties = () => {\r\n        let content;\r\n        let footer;\r\n        if(properties.length > 0) {\r\n            const data = properties.map((item) => {\r\n                return <p>{item.id + \" \" + item.value}</p>\r\n            })\r\n\r\n            content = (\r\n                <React.Fragment>\r\n                    {data}\r\n                </React.Fragment>\r\n            )\r\n\r\n            footer = (\r\n                <React.Fragment>\r\n                    <Button type=\"primary\" style={{marginRight:\"32%\"}} onClick={() => setProperties([])}>Generate Different Properties</Button>\r\n                    <Button key=\"back\" onClick={() => {setShowProperties(false)}}>\r\n                        Return\r\n                    </Button>\r\n                    <Button key=\"submit\" type=\"primary\" onClick={() => {setShowProperties(false)}}>\r\n                        Confirm\r\n                    </Button>\r\n                </React.Fragment>\r\n            )\r\n        } else {\r\n            content = (\r\n                <div style={{display:\"flex\", justifyContent:\"center\"}}>\r\n                    <Checkbox.Group style={{display:\"flex\", width:\"180px\", flexWrap:\"wrap\"}} options={options1} />\r\n                    <Checkbox.Group style={{display:\"flex\", width:\"180px\", flexWrap:\"wrap\"}} options={options2} />\r\n                    <Checkbox.Group style={{display:\"flex\", width:\"180px\", flexWrap:\"wrap\"}} options={options3} />\r\n                </div>\r\n            )\r\n        }\r\n        return (\r\n            <Modal style={{top: \"25%\"}} width={\"600px\"} bodyStyle={{minHeight:\"200px\"}} title=\"Graph Properties\" visible={showProperties} onOk={() => {setShowProperties(false)}} onCancel={() => {setShowProperties(false)}}\r\n                    footer={footer}>\r\n                {content}\r\n            </Modal>\r\n        )\r\n    }\r\n\r\n    const addOrDeleteEdge = (bool) => {\r\n        if(v1 !== \"\" && v2 !== \"\") {\r\n            let success;\r\n            if(bool) {\r\n                success = props.addEdge(v1, v2);\r\n            } else {\r\n                success = props.deleteEdge(v1, v2);\r\n            }\r\n            setAddEdgeValidStatus1(success[0]);\r\n            setAddEdgeValidStatus2(success[1]);\r\n            return success;\r\n        } else {\r\n            let k = [];\r\n            if(v1 === \"\") {\r\n                k.push(\"error\")\r\n            } else {\r\n                k.push(\"none\")\r\n            }\r\n\r\n            if(v2 === \"\") {\r\n                k.push(\"error\")\r\n            } else {\r\n                k.push(\"none\");\r\n            }\r\n            setAddEdgeValidStatus1(k[0]);\r\n            setAddEdgeValidStatus2(k[1]);\r\n            return k;\r\n        }\r\n    }\r\n\r\n    const getEditEdge = () => {\r\n        const footer = (\r\n            <React.Fragment>\r\n                <Button key=\"back\" onClick={() => {setEditEdge(false); setAddEdge(false); setDeleteEdge(false)}}>\r\n                    Return\r\n                </Button>\r\n                <Button type=\"primary\" onClick={() => {\r\n                        addEdge ? addOrDeleteEdge(true) : addOrDeleteEdge(false)\r\n                    }\r\n                }>\r\n                    {addEdge ? \"Add Edge\" : \"Delete Edge\"}\r\n                </Button>\r\n            </React.Fragment>\r\n        )\r\n\r\n        return (\r\n            <Modal style={{top: \"25%\"}} title={addEdge ? \"Add Edge\" : \"Delete Edge\"} visible={editEdge} onCancel={() => {setEditEdge(false); setAddEdge(false); setDeleteEdge(false);\r\n                    setAddEdgeValidStatus1(\"none\"); setAddEdgeValidStatus2(\"none\")}} footer={footer}>\r\n                 <div style={{display:\"flex\", width:\"100%\", justifyContent:\"center\", marginTop:\"10px\", marginBottom:\"-5px\", marginLeft:\"-10px\"}}>\r\n                    <Form\r\n                        initialValues={{ remember: true }}\r\n                        onMouseDown={() => {setAddEdgeValidStatus1(\"none\"); console.log(\"?\")\r\n                        setAddEdgeValidStatus2(\"none\")}}\r\n                        >\r\n                        <Form.Item\r\n                            label=\"Vertex 1\"\r\n                            name=\"v1\"\r\n                            validateStatus={addEdgeValidStatus1}\r\n                            help={addEdgeValidStatus1 === \"error\" ? \"Invalid Input\" : null}\r\n                        >\r\n                            <Input onPressEnter={(e) => {addEdge ? addOrDeleteEdge(true) : addOrDeleteEdge(false)}} autoComplete=\"off\" onChange={(e) => setV1(e.target.value)} />\r\n                        </Form.Item>\r\n                        <Form.Item\r\n                            validateStatus={addEdgeValidStatus2}\r\n                            help={addEdgeValidStatus2 === \"error\" ? \"Invalid Input\" : null}\r\n                            label=\"Vertex 2\"\r\n                            name=\"v2\"\r\n                        >\r\n                            <Input onPressEnter={(e) => {addEdge ? addOrDeleteEdge(true) : addOrDeleteEdge(false)}} autoComplete=\"off\" onChange={(e) => setV2(e.target.value)} />\r\n                        </Form.Item>\r\n                    </Form>\r\n                 </div>\r\n            </Modal>\r\n        )\r\n    }\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <div style={{position:\"absolute\", display:\"flex\", marginTop:\"20px\", marginLeft:\"20px\"}} >\r\n                <Button style={{margin: \"8px\", height:\"35px\", width:\"150px\", fontSize:\"15px\"}} type=\"primary\" onClick={() => setShowInput(true)}>Input Graph</Button>\r\n                <Button style={{margin: \"8px\", height:\"35px\", width:\"150px\", fontSize:\"15px\"}} type=\"primary\" onClick={() => {props.straightenEdges()}}>Straighten Edges</Button>\r\n                <Button style={{margin: \"8px\", height:\"35px\", width:\"150px\", fontSize:\"15px\"}} type=\"primary\" onClick={() => setShowProperties(true)}>Graph Properties</Button>\r\n                <Authentication />\r\n            </div>\r\n            {getGraphInput()}\r\n            {getProperties()}\r\n            {getEditEdge()}\r\n            <div style={{position:\"absolute\", display:\"flex\", right:\"3%\", bottom:\"6%\", flexWrap:\"wrap\", width:\"125px\"}}>\r\n                <Button style={{margin:\"8px\", height:\"45px\", width:\"95px\", fontSize:\"15px\", padding:\"0px\"}} type=\"primary\" \r\n                        onClick={() => {setDeleteEdge(true); setEditEdge(true);}}>\r\n                    Delete Edge\r\n                </Button>\r\n                <Button style={{margin:\"8px\", height:\"45px\", width:\"95px\", fontSize:\"15px\", padding:\"0px\"}} type=\"primary\" \r\n                        onClick={() => {props.setDeletingVertex(true)}}>\r\n                    Delete Node\r\n                </Button>\r\n                <Button style={{margin:\"8px\", height:\"45px\", width:\"95px\", fontSize:\"15px\", padding:\"0px\"}} type=\"primary\" \r\n                    onClick={() => {setAddEdge(true); setEditEdge(true)}}>\r\n                    Add Edge\r\n                </Button>\r\n                <Button style={{margin:\"8px\", height:\"45px\", width:\"95px\", fontSize:\"15px\", padding:\"0px\"}} type=\"primary\" \r\n                    onClick={() => {props.setAddingVertex(true)}}>\r\n                    Add Node\r\n                </Button>\r\n            </div>\r\n        </React.Fragment>\r\n    )\r\n}\r\n","D:\\Graph Theory Tool\\front\\src\\display\\input\\InputGraph.js",["113","114","115"],"export default class InputGraph {\r\n    constructor(vertices, edges) {\r\n        console.log(edges);\r\n        this.vertices = [];\r\n        for(let i = 0; i < vertices; ++i) {\r\n            this.vertices.push({\"id\": i, \"posX\": 500, \"posY\": 500});\r\n        }\r\n\r\n        this.edges = new Map;\r\n        this.bendPositions = new Map;\r\n        this.valid = true;\r\n        this.errors = [];\r\n        for(let i = 0; i < edges.length; ++i) {\r\n            this.errors.push(\"none\");\r\n            for(let neighbor of edges[i]) {\r\n                if(!this.addEdge(i, neighbor)) {\r\n                    this.valid = false;\r\n                    this.errors[i] = (\"error\");\r\n                    break;\r\n                } else if (neighbor === \"\") {\r\n                    this.errors[i] = (\"error\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    addEdge = (v1, v2) => {\r\n        if(!(/^\\d+$/.test(v1)) || !(/^\\d+$/.test(v2))) {\r\n            return false;\r\n        }\r\n\r\n        v1 = Number(v1);\r\n        v2 = Number(v2);\r\n        if(!(Number.isInteger(v1)) || v1 > this.vertices.length - 1) {\r\n            return false;\r\n        }\r\n        if(!(Number.isInteger(v2)) || v2 > this.vertices.length - 1) {\r\n            return false;\r\n        }\r\n\r\n        if(v1 == v2) {\r\n            return false;\r\n        }\r\n        \r\n        let key;\r\n        if(v1 > v2) {\r\n            key = v2 + \".\" + v1;\r\n        } else {\r\n            key = v1 + \".\" + v2;\r\n        }\r\n        \r\n        this.edges.set(key, {\r\n            \"id\": key,\r\n            \"node1\": v1,\r\n            \"node2\": v2,\r\n            \"bent\": false,\r\n            \"posX\": null,\r\n            \"posY\": null\r\n        });\r\n\r\n\r\n        this.bendPositions.set(key, {\r\n            \"id\": key,\r\n            \"bent\": false,\r\n            \"posX\": null,\r\n            \"posY\": null\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n}","D:\\Graph Theory Tool\\front\\src\\display\\authentication\\Authentication.js",["116"],"D:\\Graph Theory Tool\\front\\src\\routing\\Routes.js",[],"D:\\Graph Theory Tool\\front\\src\\display\\authentication\\TokenPage.js",["117","118"],{"ruleId":"119","replacedBy":"120"},{"ruleId":"121","replacedBy":"122"},{"ruleId":"123","severity":1,"message":"124","line":1,"column":8,"nodeType":"125","messageId":"126","endLine":1,"endColumn":12},{"ruleId":"123","severity":1,"message":"127","line":5,"column":8,"nodeType":"125","messageId":"126","endLine":5,"endColumn":19},{"ruleId":"123","severity":1,"message":"128","line":6,"column":21,"nodeType":"125","messageId":"126","endLine":6,"endColumn":29},{"ruleId":"123","severity":1,"message":"129","line":7,"column":20,"nodeType":"125","messageId":"126","endLine":7,"endColumn":31},{"ruleId":"123","severity":1,"message":"130","line":7,"column":33,"nodeType":"125","messageId":"126","endLine":7,"endColumn":42},{"ruleId":"123","severity":1,"message":"131","line":16,"column":9,"nodeType":"125","messageId":"126","endLine":16,"endColumn":17},{"ruleId":"123","severity":1,"message":"132","line":1,"column":8,"nodeType":"125","messageId":"126","endLine":1,"endColumn":14},{"ruleId":"123","severity":1,"message":"133","line":3,"column":8,"nodeType":"125","messageId":"126","endLine":3,"endColumn":17},{"ruleId":"123","severity":1,"message":"134","line":4,"column":8,"nodeType":"125","messageId":"126","endLine":4,"endColumn":17},{"ruleId":"135","severity":1,"message":"136","line":19,"column":28,"nodeType":"137","messageId":"138","endLine":19,"endColumn":30},{"ruleId":"135","severity":1,"message":"136","line":39,"column":24,"nodeType":"137","messageId":"138","endLine":39,"endColumn":26},{"ruleId":"135","severity":1,"message":"136","line":21,"column":27,"nodeType":"137","messageId":"138","endLine":21,"endColumn":29},{"ruleId":"135","severity":1,"message":"136","line":57,"column":27,"nodeType":"137","messageId":"138","endLine":57,"endColumn":29},{"ruleId":"135","severity":1,"message":"139","line":94,"column":42,"nodeType":"137","messageId":"138","endLine":94,"endColumn":44},{"ruleId":"123","severity":1,"message":"140","line":1,"column":37,"nodeType":"125","messageId":"126","endLine":1,"endColumn":43},{"ruleId":"123","severity":1,"message":"141","line":6,"column":12,"nodeType":"125","messageId":"126","endLine":6,"endColumn":19},{"ruleId":"123","severity":1,"message":"140","line":1,"column":37,"nodeType":"125","messageId":"126","endLine":1,"endColumn":43},{"ruleId":"123","severity":1,"message":"142","line":1,"column":26,"nodeType":"125","messageId":"126","endLine":1,"endColumn":35},{"ruleId":"123","severity":1,"message":"143","line":8,"column":12,"nodeType":"125","messageId":"126","endLine":8,"endColumn":32},{"ruleId":"123","severity":1,"message":"144","line":8,"column":34,"nodeType":"125","messageId":"126","endLine":8,"endColumn":57},{"ruleId":"123","severity":1,"message":"145","line":11,"column":12,"nodeType":"125","messageId":"126","endLine":11,"endColumn":26},{"ruleId":"123","severity":1,"message":"146","line":11,"column":28,"nodeType":"125","messageId":"126","endLine":11,"endColumn":45},{"ruleId":"123","severity":1,"message":"147","line":14,"column":12,"nodeType":"125","messageId":"126","endLine":14,"endColumn":22},{"ruleId":"123","severity":1,"message":"148","line":17,"column":12,"nodeType":"125","messageId":"126","endLine":17,"endColumn":24},{"ruleId":"123","severity":1,"message":"149","line":17,"column":26,"nodeType":"125","messageId":"126","endLine":17,"endColumn":41},{"ruleId":"150","severity":1,"message":"151","line":9,"column":22,"nodeType":"152","messageId":"153","endLine":9,"endColumn":29,"fix":"154"},{"ruleId":"150","severity":1,"message":"151","line":10,"column":30,"nodeType":"152","messageId":"153","endLine":10,"endColumn":37,"fix":"155"},{"ruleId":"135","severity":1,"message":"136","line":41,"column":15,"nodeType":"137","messageId":"138","endLine":41,"endColumn":17},{"ruleId":"123","severity":1,"message":"156","line":3,"column":24,"nodeType":"125","messageId":"126","endLine":3,"endColumn":37},{"ruleId":"123","severity":1,"message":"157","line":5,"column":16,"nodeType":"125","messageId":"126","endLine":5,"endColumn":21},{"ruleId":"158","severity":1,"message":"159","line":22,"column":8,"nodeType":"160","endLine":22,"endColumn":10,"suggestions":"161"},"no-native-reassign",["162"],"no-negated-in-lhs",["163"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'GraphVisual' is defined but never used.","'useState' is defined but never used.","'BFSNoRepeat' is defined but never used.","'BFSRepeat' is defined but never used.","'vertices' is assigned a value but never used.","'Cycles' is defined but never used.","'Planarity' is defined but never used.","'SpanTrees' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'useRef' is defined but never used.","'bendPos' is assigned a value but never used.","'useEffect' is defined but never used.","'isUpdatingProperties' is assigned a value but never used.","'setIsUpdatingProperties' is assigned a value but never used.","'prevProperties' is assigned a value but never used.","'setPrevProperties' is assigned a value but never used.","'deleteEdge' is assigned a value but never used.","'graphOptions' is assigned a value but never used.","'setGraphOptions' is assigned a value but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"164","text":"165"},{"range":"166","text":"165"},"'setSubmitBool' is assigned a value but never used.","'setID' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'submit'. Either include it or remove the dependency array.","ArrayExpression",["167"],"no-global-assign","no-unsafe-negation",[285,285],"()",[324,324],{"desc":"168","fix":"169"},"Update the dependencies array to be: [submit]",{"range":"170","text":"171"},[715,717],"[submit]"]