[{"D:\\Graph Theory Tool\\front\\src\\index.js":"1","D:\\Graph Theory Tool\\front\\src\\App.js":"2","D:\\Graph Theory Tool\\front\\src\\reportWebVitals.js":"3","D:\\Graph Theory Tool\\front\\src\\logic\\graph\\Graph.js":"4","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Planarity.js":"5","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Hamiltonian.js":"6","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\SpanTrees.js":"7","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Cycles.js":"8","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Components.js":"9","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\BFS.js":"10","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\GraphVisual.js":"11","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Edge.js":"12","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Node.js":"13","D:\\Graph Theory Tool\\front\\src\\display\\data\\Data.js":"14","D:\\Graph Theory Tool\\front\\src\\display\\input\\Input.js":"15"},{"size":500,"mtime":1608943103064,"results":"16","hashOfConfig":"17"},{"size":901,"mtime":1609330634946,"results":"18","hashOfConfig":"17"},{"size":362,"mtime":1608943103064,"results":"19","hashOfConfig":"17"},{"size":2400,"mtime":1609225751772,"results":"20","hashOfConfig":"17"},{"size":107,"mtime":1608957101461,"results":"21","hashOfConfig":"17"},{"size":295,"mtime":1608961678554,"results":"22","hashOfConfig":"17"},{"size":106,"mtime":1608957102494,"results":"23","hashOfConfig":"17"},{"size":466,"mtime":1609028646681,"results":"24","hashOfConfig":"17"},{"size":1282,"mtime":1609225152031,"results":"25","hashOfConfig":"17"},{"size":3215,"mtime":1608979201557,"results":"26","hashOfConfig":"17"},{"size":3825,"mtime":1609331499200,"results":"27","hashOfConfig":"17"},{"size":1850,"mtime":1609297961183,"results":"28","hashOfConfig":"17"},{"size":739,"mtime":1609330868472,"results":"29","hashOfConfig":"17"},{"size":2522,"mtime":1609330723670,"results":"30","hashOfConfig":"17"},{"size":1030,"mtime":1609330151938,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"cgvn3b",{"filePath":"35","messages":"36","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"34"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"34"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"34"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"D:\\Graph Theory Tool\\front\\src\\index.js",[],["66","67"],"D:\\Graph Theory Tool\\front\\src\\App.js",["68","69","70","71","72"],"D:\\Graph Theory Tool\\front\\src\\reportWebVitals.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\graph\\Graph.js",["73","74","75","76","77"],"import Cycles from '../algorithms/Cycles'\r\nimport Hamiltonian from '../algorithms/Hamiltonian'\r\nimport Planarity from '../algorithms/Planarity'\r\nimport SpanTrees from '../algorithms/SpanTrees'\r\nimport Components from '../algorithms/Components'\r\n\r\n\r\nclass Graph {\r\n    constructor(adjMatrix) {\r\n        this.list = this.makeAdjacenyList(adjMatrix);\r\n        this.matrix = adjMatrix;\r\n    }\r\n\r\n    makeAdjacenyList = (m) => {\r\n        let list = [];\r\n        for(let v = 0; v < m.length; ++v) {\r\n            let current = [];\r\n            for(let i = 0; i < m.length; ++i) {\r\n                if(m[v][i] == 1) {\r\n                    current.push(i);\r\n                }\r\n            }\r\n\r\n            list.push(current);\r\n        }\r\n\r\n        return list;\r\n    }\r\n\r\n    getCompleteSubgraph(vertices) {\r\n        \r\n    }\r\n\r\n    getSubgraph(vertices, adjacencyList) {\r\n\r\n    }\r\n\r\n    getRequirement = (requirement) => {\r\n        if(requirement == \"components\") {\r\n            this.getComponents();\r\n        }\r\n    }\r\n\r\n    // returns the number of components in G;\r\n    getComponents = () => {\r\n        const components = Components(this);\r\n        this.compenents = components.getComponents();\r\n    }\r\n\r\n    // returns all hamiltonian cycles in G;\r\n    getHamiltonianCycles = () => {\r\n        const hamiltonian = Hamiltonian(this);\r\n        this.hamiltonianCycleCount = hamiltonian.getHamiltonianCycleCount();\r\n        this.hamiltonianCycles = hamiltonian.getHamiltonianCycles();\r\n    }\r\n    \r\n\r\n}\r\n\r\nexport default Graph;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* // returns an array of graphs (which are subgraphs of G which happen to be spanning trees/forests)\r\n    spanTrees = () => {\r\n        const trees = SpanTrees.getTrees(this);\r\n        return trees;\r\n    }\r\n\r\n    // returns the number of spanning trees\r\n    numberOfSpanTrees = () => {\r\n        const treeCount = SpanTrees.getTreeCount(this);\r\n        return treeCount;\r\n    }\r\n\r\n    // returns a boolean as to whether or not this graph is planar\r\n    planarity = () => {\r\n        let b = Planarity.getPlanarity(this);\r\n        return b;\r\n    }\r\n\r\n    // returns a K_(3,3) or K_5 subdivision\r\n    nonPlanar = () => {\r\n        let b = Planarity.getSubdivision(this);\r\n        return b;\r\n    }\r\n\r\n    // returns smallest + largest cycle in G (array of Graphs);\r\n    cycles = () => {\r\n        const cycleArray = Cycles.getCycles(this);\r\n        return cycleArray;\r\n    }\r\n*/","D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Planarity.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Hamiltonian.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\SpanTrees.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Cycles.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\Components.js",[],"D:\\Graph Theory Tool\\front\\src\\logic\\algorithms\\BFS.js",["78","79","80"],"// returns an array of all the paths branching from one vertex\r\nfunction BFSRepeat(G, vertex) {\r\n    let paths = [[vertex]];\r\n    let finishedPaths = [];\r\n    let list = G.list;\r\n\r\n    while(paths.length > 0) {\r\n        let newPaths = [];\r\n        for(let i = 0; i < paths.length; ++i) {\r\n            let path = paths[i];\r\n            let prevLength = newPaths.length;\r\n            let idx = path[path.length - 1];\r\n            for(let v of list[idx]) {\r\n                if(!path.includes(v)) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    newPaths.push(newPath);\r\n                }\r\n            }\r\n\r\n            if(prevLength == newPaths.length) {\r\n                finishedPaths.push(path);\r\n                paths.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n        paths = newPaths;\r\n    }\r\n    return finishedPaths;\r\n}\r\n\r\nfunction BFSCycle(G, vertex) {\r\n    let paths = [[vertex]];\r\n    let finishedPaths = [];\r\n    let list = G.list;\r\n\r\n    while(paths.length > 0) {\r\n        let newPaths = [];\r\n        for(let i = 0; i < paths.length; ++i) {\r\n            let path = paths[i];\r\n            let prevLength = newPaths.length;\r\n            let idx = path[path.length - 1];\r\n            for(let v of list[idx]) {\r\n                if(!path.includes(v)) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    newPaths.push(newPath);\r\n                }\r\n\r\n                if(v === vertex && path.length > 2) {\r\n                    let newPath = path.slice(0);\r\n                    newPath.push(v);\r\n                    finishedPaths.push(newPath);\r\n                }\r\n            }\r\n\r\n            if(prevLength == newPaths.length) {\r\n                paths.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n        paths = newPaths;\r\n    }\r\n    \r\n    for(let path of finishedPaths) {\r\n        if(path[1] > path[path.length - 2]) {\r\n            path.reverse();\r\n        }\r\n    }\r\n\r\n    let finishedCycles = Array.from(new Set(finishedPaths.map(JSON.stringify)), JSON.parse);\r\n\r\n    return finishedCycles;\r\n}\r\n\r\n// input: G is the graph, vertex is the starting vertex, and removedVertices\r\n// is an array consisting of the vertices currently in your search already\r\n// (array of 1's and 0's, 1 meaning the vertex is included, 0 meaning not included)\r\n\r\n// returns two arrays: One with all the vertices you can reach in the bfs, \r\n// and one with all the vertices you cannot reach using bfs\r\n\r\nfunction BFSNoRepeat(G, vertex, vertices) {\r\n    let list = G.list;\r\n    let currentVertices = [vertex];\r\n    let vertexMap = vertices;\r\n\r\n    vertexMap[vertex] = 1;\r\n\r\n    while(currentVertices.length > 0) {\r\n        let newVertices = [];\r\n        for(let v of currentVertices) {\r\n            for(let i = 0; i < list[v].length; ++i) {\r\n                if(vertexMap[list[v][i]] != 1) {\r\n                    ++vertexMap[list[v][i]];\r\n                    newVertices.push(list[v][i]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        currentVertices = newVertices.slice(0);\r\n    }\r\n    \r\n    return vertexMap;\r\n}\r\n\r\nexport {BFSRepeat, BFSNoRepeat, BFSCycle};\r\n\r\n","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\GraphVisual.js",["81","82"],"D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Edge.js",["83"],"import React, {useState, useEffect} from 'react'\r\n\r\nfunction Edge(props) {\r\n    const [node1, setNode1] = useState(props.node1);\r\n    const [node2, setNode2] = useState(props.node2);\r\n    const [bendPos, setBendPos] = useState(props.bendPos);\r\n\r\n    let c;\r\n    let d;\r\n    if(props.bendPos.bent === false) {\r\n        c = [(node1.posX + node2.posX)/2, (node1.posY + node2.posY)/2];\r\n        d = \"M \" + node1.posX + \" \" + node1.posY + \" Q \" + c[0] + \" \" + c[1] + \" \" + node2.posX + \" \" + node2.posY;\r\n    } else {\r\n        c = [props.bendPos.posX, props.bendPos.posY];\r\n        d = calcCirclePath([[node2.posX, node2.posY], c, [node1.posX, node1.posY]]);\r\n    }\r\n\r\n    useEffect(() => {\r\n        setNode1(props.node1); setNode2(props.node2);\r\n        setBendPos(props.bendPos);\r\n    }, [props.node1, props.node2, props.bendPos])\r\n\r\n    return (\r\n        <svg>\r\n            <path d={d} stroke=\"black\" fill=\"transparent\" stroke-width=\"2\"/>\r\n            <circle onMouseDown={(e) => {props.dragStart(e, props.id, false)}} onMouseUp={(e) => props.dragEnd(e)} cx={c[0]} cy={c[1]} r={6}/>\r\n        </svg>\r\n    )\r\n}\r\n\r\nfunction calcCirclePath(points){\r\n    var a = points[0]\r\n    var b = points[2]\r\n    var c = points[1]\r\n  \r\n    var A = dist(b, c)\r\n    var B = dist(c, a)\r\n    var C = dist(a, b)\r\n  \r\n    var angle = Math.acos((A*A + B*B - C*C)/(2*A*B))\r\n  \r\n    //calc radius of circle\r\n    var K = .5*A*B*Math.sin(angle)\r\n    var r = A*B*C/4/K\r\n    r = Math.round(r*1000)/1000\r\n  \r\n    //large arc flag\r\n    var laf = +(Math.PI/2 > angle)\r\n  \r\n    //sweep flag\r\n    var saf = +((b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0]) < 0) \r\n  \r\n    return ['M', a, 'A', r, r, 0, laf, saf, b].join(' ')\r\n  }\r\n  \r\n  function dist(a, b){\r\n    return Math.sqrt(\r\n      Math.pow(a[0] - b[0], 2) +\r\n      Math.pow(a[1] - b[1], 2))\r\n  }\r\n\r\nexport default Edge\r\n","D:\\Graph Theory Tool\\front\\src\\display\\graphs\\Node.js",["84"],"D:\\Graph Theory Tool\\front\\src\\display\\data\\Data.js",["85"],"D:\\Graph Theory Tool\\front\\src\\display\\input\\Input.js",[],{"ruleId":"86","replacedBy":"87"},{"ruleId":"88","replacedBy":"89"},{"ruleId":"90","severity":1,"message":"91","line":1,"column":8,"nodeType":"92","messageId":"93","endLine":1,"endColumn":12},{"ruleId":"90","severity":1,"message":"94","line":5,"column":8,"nodeType":"92","messageId":"93","endLine":5,"endColumn":19},{"ruleId":"90","severity":1,"message":"95","line":6,"column":21,"nodeType":"92","messageId":"93","endLine":6,"endColumn":29},{"ruleId":"90","severity":1,"message":"96","line":7,"column":20,"nodeType":"92","messageId":"93","endLine":7,"endColumn":31},{"ruleId":"90","severity":1,"message":"97","line":7,"column":33,"nodeType":"92","messageId":"93","endLine":7,"endColumn":42},{"ruleId":"90","severity":1,"message":"98","line":1,"column":8,"nodeType":"92","messageId":"93","endLine":1,"endColumn":14},{"ruleId":"90","severity":1,"message":"99","line":3,"column":8,"nodeType":"92","messageId":"93","endLine":3,"endColumn":17},{"ruleId":"90","severity":1,"message":"100","line":4,"column":8,"nodeType":"92","messageId":"93","endLine":4,"endColumn":17},{"ruleId":"101","severity":1,"message":"102","line":19,"column":28,"nodeType":"103","messageId":"104","endLine":19,"endColumn":30},{"ruleId":"101","severity":1,"message":"102","line":39,"column":24,"nodeType":"103","messageId":"104","endLine":39,"endColumn":26},{"ruleId":"101","severity":1,"message":"102","line":21,"column":27,"nodeType":"103","messageId":"104","endLine":21,"endColumn":29},{"ruleId":"101","severity":1,"message":"102","line":57,"column":27,"nodeType":"103","messageId":"104","endLine":57,"endColumn":29},{"ruleId":"101","severity":1,"message":"105","line":94,"column":42,"nodeType":"103","messageId":"104","endLine":94,"endColumn":44},{"ruleId":"90","severity":1,"message":"106","line":1,"column":37,"nodeType":"92","messageId":"93","endLine":1,"endColumn":43},{"ruleId":"90","severity":1,"message":"107","line":9,"column":19,"nodeType":"92","messageId":"93","endLine":9,"endColumn":27},{"ruleId":"90","severity":1,"message":"108","line":6,"column":12,"nodeType":"92","messageId":"93","endLine":6,"endColumn":19},{"ruleId":"90","severity":1,"message":"106","line":1,"column":37,"nodeType":"92","messageId":"93","endLine":1,"endColumn":43},{"ruleId":"90","severity":1,"message":"107","line":25,"column":19,"nodeType":"92","messageId":"93","endLine":25,"endColumn":27},"no-native-reassign",["109"],"no-negated-in-lhs",["110"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'GraphVisual' is defined but never used.","'useState' is defined but never used.","'BFSNoRepeat' is defined but never used.","'BFSRepeat' is defined but never used.","'Cycles' is defined but never used.","'Planarity' is defined but never used.","'SpanTrees' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'useRef' is defined but never used.","'setEdges' is assigned a value but never used.","'bendPos' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]